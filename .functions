# Create a new directory and enter it
function md() {
        mkdir -p "$@" && cd "$@"
}

# find shorthand
function f() {
    find . -name "$1"
}

# cd into whatever is the forefront Finder window.
cdf() {  # short for cdfinder
  cd "`osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)'`"
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
        local port="${1:-8000}"
        open "http://localhost:${port}/"
        # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
        # And serve everything as UTF-8 (although not technically correct, this doesnâ€™t break anything for binary files)
        python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# Test if HTTP compression (RFC 2616 + SDCH) is enabled for a given URL.
# Send a fake UA string for sites that sniff it instead of using the Accept-Encoding header. (Looking at you, ajax.googleapis.com!)
function httpcompression() {
        encoding="$(curl -LIs -H 'User-Agent: Mozilla/5 Gecko' -H 'Accept-Encoding: gzip,deflate,compress,sdch' "$1" | grep '^Content-Encoding:')" && echo "$1 is encoded using ${encoding#* }" || echo "$1 is not using any encoding"
}

# Extract archives - use: extract <file>
# Based on http://dotfiles.org/~pseup/.bashrc
function extract() {
        if [ -f "$1" ] ; then
                local filename=$(basename "$1")
                local foldername="${filename%%.*}"
                local fullpath=`perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"`
                local didfolderexist=false
                if [ -d "$foldername" ]; then
                        didfolderexist=true
                        read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1
                        echo
                        if [[ $REPLY =~ ^[Nn]$ ]]; then
                                return
                        fi
                fi
                mkdir -p "$foldername" && cd "$foldername"
                case $1 in
                        *.tar.bz2) tar xjf "$fullpath" ;;
                        *.tar.gz) tar xzf "$fullpath" ;;
                        *.tar.xz) tar Jxvf "$fullpath" ;;
                        *.tar.Z) tar xzf "$fullpath" ;;
                        *.tar) tar xf "$fullpath" ;;
                        *.taz) tar xzf "$fullpath" ;;
                        *.tb2) tar xjf "$fullpath" ;;
                        *.tbz) tar xjf "$fullpath" ;;
                        *.tbz2) tar xjf "$fullpath" ;;
                        *.tgz) tar xzf "$fullpath" ;;
                        *.txz) tar Jxvf "$fullpath" ;;
                        *.zip) unzip "$fullpath" ;;
                        *) echo "'$1' cannot be extracted via extract()" && cd .. && ! $didfolderexist && rm -r "$foldername" ;;
                esac
        else
                echo "'$1' is not a valid file"
        fi
}

# This runs the compass compile command in all child directories
# usefull for compiling multiple skins based on a default skin
function compcompile() {
  for dir in */
  do
    dir=${dir%*/}
    compass compile ${dir}
  done
}

# Create a logbook entry
function lb() {
    vim ~/logbook/$(date '+%Y-%m-%d').md
}

function printlb() {
  for filename in $HOME/logbook/*; do
    echo "\033[0;32m$filename\033[0m"
    cat "$filename"
  done
}

function kGcrSecret() {
  kubectl delete secret gcr;
  kubectl create secret docker-registry gcr \
    --docker-server=https://eu.gcr.io \
    --docker-username=oauth2accesstoken \
    --docker-password="$(gcloud auth print-access-token)" \
    --docker-email=mheimensen@xebia.com
}
